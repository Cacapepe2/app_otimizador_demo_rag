def gerar_sigla_sugerida(municipio, site, uf, usados, df_total):
    stopwords = {"DE", "DO", "DA", "DOS", "DAS", "E"}

    def limpar(palavra):
        palavra = unidecode(palavra.strip().upper())
        palavra = re.sub(r"[^A-Z]", "", palavra)  # remove tudo que não for letra maiúscula
        return palavra

    # Limpa e filtra stopwords
    municipio_parts = [limpar(w) for w in municipio.split() if limpar(w) and limpar(w) not in stopwords]
    site_parts = [limpar(w) for w in site.split() if limpar(w) and limpar(w) not in stopwords]

    # Validação: Se município ou site ficaram vazios após limpeza
    if not municipio_parts:
        municipio_parts = ["XXX"]  # Fallback
    if not site_parts:
        site_parts = ["XXX"]  # Fallback

    # Pega última palavra do município (geralmente a mais significativa)
    m = municipio_parts[-1] if municipio_parts else "X"
    
    # Se município só tem 1 letra, tenta usar a primeira palavra também
    if len(m) < 2 and len(municipio_parts) > 1:
        m = municipio_parts[0][:2] if len(municipio_parts[0]) >= 2 else municipio_parts[0]

    candidates = []

    # Regra 1: Site com 3+ palavras → 1ª letra de cada
    if len(site_parts) >= 3:
        if all(len(p) >= 1 for p in site_parts[:3]):
            candidates.append(site_parts[0][0] + site_parts[1][0] + site_parts[2][0])
    
    # Regra 2: Site com 2 palavras → 2 letras da 1ª + 1 letra da 2ª
    if len(site_parts) >= 2:
        if len(site_parts[0]) >= 2 and len(site_parts[1]) >= 1:
            candidates.append(site_parts[0][:2] + site_parts[1][0])
    
    # Regra 3: 1ª letra município + 2 primeiras do site (1ª palavra)
    if len(m) >= 1 and len(site_parts[0]) >= 2:
        candidates.append(m[0] + site_parts[0][:2])
    
    # Regra 4: 2 primeiras do município + 1ª do site
    if len(m) >= 2 and len(site_parts[0]) >= 1:
        candidates.append(m[:2] + site_parts[0][0])
    
    # Regra 5: 1ª município + 1ª de cada palavra do site (se tiver 2 palavras)
    if len(site_parts) >= 2 and len(m) >= 1:
        if len(site_parts[0]) >= 1 and len(site_parts[1]) >= 1:
            candidates.append(m[0] + site_parts[0][0] + site_parts[1][0])
    
    # Regra 6: 1ª município + 2ª letra 1ª palavra + 1ª da 2ª palavra
    if len(site_parts) >= 2 and len(m) >= 1:
        if len(site_parts[0]) >= 2 and len(site_parts[1]) >= 1:
            candidates.append(m[0] + site_parts[0][1] + site_parts[1][0])
    
    # Regra 7: Site com 1 palavra → 3 primeiras letras
    if len(site_parts) == 1 and len(site_parts[0]) >= 3:
        candidates.append(site_parts[0][:3])
    
    # Regra 8: 1ª município + 1ª e 2ª do site (para sites de 1 palavra)
    if len(site_parts) == 1 and len(m) >= 1 and len(site_parts[0]) >= 2:
        candidates.append(m[0] + site_parts[0][:2])

    # Regra 9: Varredura monotônica (todas as combinações possíveis)
    bloco = m + "".join(site_parts)
    if len(bloco) >= 3:
        for i in range(len(bloco)):
            for j in range(i + 1, len(bloco)):
                for k in range(j + 1, len(bloco)):
                    candidates.append(bloco[i] + bloco[j] + bloco[k])

    # Normaliza todos os candidatos
    candidates = [c.upper() for c in candidates if len(c) == 3]

    # Remove duplicatas mantendo ordem
    seen = set()
    candidates = [x for x in candidates if not (x in seen or seen.add(x))]

    # Checa unicidade contra df_total e já usados
    usados_uf = set(df_total.loc[df_total["SIG_ESTADO"] == uf, "SIG_SITE"].unique())
    for cand in candidates:
        if cand not in usados[uf] and cand not in usados_uf:
            usados[uf].add(cand)
            return cand

    # Se nenhuma sigla estiver disponível, gera uma com número incremental
    if len(site_parts[0]) >= 2:
        base = (m[0] + site_parts[0][:2]).upper()
    elif len(site_parts[0]) == 1:
        base = (m[0] + site_parts[0][0] + "X").upper()
    else:
        base = (m[:2] + "X").upper() if len(m) >= 2 else "XXX"
    
    numero = 2
    tentativas = 0
    while tentativas < 1000:  # Limite de segurança
        sigla_numerada = f"{base}{numero}"
        if len(sigla_numerada) <= 6:  # Garante que não fica muito longa
            if sigla_numerada not in usados[uf] and sigla_numerada not in usados_uf:
                usados[uf].add(sigla_numerada)
                return sigla_numerada
        numero += 1
        tentativas += 1
    
    # Último recurso
    return "XXX"
