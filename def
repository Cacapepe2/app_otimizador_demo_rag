def gerar_sigla_sugerida(municipio, site, uf, usados, df_total):
    stopwords = {"DE", "DO", "DA", "DOS", "DAS", "E"}

    def limpar(palavra):
        palavra = unidecode(palavra.strip().upper())
        palavra = re.sub(r"[^A-Z]", "", palavra)
        return palavra

    municipio_parts = [limpar(w) for w in municipio.split() if limpar(w) and limpar(w) not in stopwords]
    site_parts = [limpar(w) for w in site.split() if limpar(w) and limpar(w) not in stopwords]

    if not municipio_parts:
        municipio_parts = ["XXX"]
    if not site_parts:
        site_parts = ["XXX"]

    m = municipio_parts[-1] if municipio_parts else "X"
    
    if len(m) < 2 and len(municipio_parts) > 1:
        m = municipio_parts[0][:2] if len(municipio_parts[0]) >= 2 else municipio_parts[0]

    # Função auxiliar para gerar candidatos (usada tanto para 3 letras quanto 2 letras)
    def gerar_candidatos(municipio_letra, site_palavras, tamanho=3):
        cands = []
        
        if tamanho == 3:
            # Regras originais para 3 letras
            if len(site_palavras) >= 3:
                if all(len(p) >= 1 for p in site_palavras[:3]):
                    cands.append(site_palavras[0][0] + site_palavras[1][0] + site_palavras[2][0])
            
            if len(site_palavras) >= 2:
                if len(site_palavras[0]) >= 2 and len(site_palavras[1]) >= 1:
                    cands.append(site_palavras[0][:2] + site_palavras[1][0])
            
            if len(municipio_letra) >= 1 and len(site_palavras[0]) >= 2:
                cands.append(municipio_letra[0] + site_palavras[0][:2])
            
            if len(municipio_letra) >= 2 and len(site_palavras[0]) >= 1:
                cands.append(municipio_letra[:2] + site_palavras[0][0])
            
            if len(site_palavras) >= 2 and len(municipio_letra) >= 1:
                if len(site_palavras[0]) >= 1 and len(site_palavras[1]) >= 1:
                    cands.append(municipio_letra[0] + site_palavras[0][0] + site_palavras[1][0])
            
            if len(site_palavras) >= 2 and len(municipio_letra) >= 1:
                if len(site_palavras[0]) >= 2 and len(site_palavras[1]) >= 1:
                    cands.append(municipio_letra[0] + site_palavras[0][1] + site_palavras[1][0])
            
            if len(site_palavras) == 1 and len(site_palavras[0]) >= 3:
                cands.append(site_palavras[0][:3])
            
            if len(site_palavras) == 1 and len(municipio_letra) >= 1 and len(site_palavras[0]) >= 2:
                cands.append(municipio_letra[0] + site_palavras[0][:2])

            # Varredura sequencial 3 letras
            bloco = municipio_letra + "".join(site_palavras)
            if len(bloco) >= 3:
                for i in range(len(bloco) - 2):
                    cands.append(bloco[i:i+3])
        
        elif tamanho == 2:
            # Regras adaptadas para 2 letras
            if len(site_palavras) >= 2:
                cands.append(site_palavras[0][0] + site_palavras[1][0])
            
            if len(site_palavras[0]) >= 2:
                cands.append(site_palavras[0][:2])
            
            if len(municipio_letra) >= 1 and len(site_palavras[0]) >= 1:
                cands.append(municipio_letra[0] + site_palavras[0][0])
            
            if len(municipio_letra) >= 2:
                cands.append(municipio_letra[:2])
            
            # Varredura sequencial 2 letras
            bloco = municipio_letra + "".join(site_palavras)
            if len(bloco) >= 2:
                for i in range(len(bloco) - 1):
                    cands.append(bloco[i:i+2])
        
        return cands

    # Tenta primeiro com 3 letras (sem número)
    candidates = gerar_candidatos(m, site_parts, tamanho=3)
    candidates = [c.upper() for c in candidates if len(c) == 3]
    
    # Remove duplicatas
    seen = set()
    candidates = [x for x in candidates if not (x in seen or seen.add(x))]

    # Checa unicidade
    usados_uf = set(df_total.loc[df_total["SIG_ESTADO"] == uf, "SIG_SITE"].unique())
    for cand in candidates:
        if cand not in usados[uf] and cand not in usados_uf:
            usados[uf].add(cand)
            return cand

    # Se não encontrou, tenta com NÚMERO na frente (2 a 9)
    for numero in range(2, 10):
        candidates_2letras = gerar_candidatos(m, site_parts, tamanho=2)
        candidates_2letras = [f"{numero}{c.upper()}" for c in candidates_2letras if len(c) == 2]
        
        # Remove duplicatas
        seen = set()
        candidates_2letras = [x for x in candidates_2letras if not (x in seen or seen.add(x))]
        
        for cand in candidates_2letras:
            if len(cand) == 3 and cand not in usados[uf] and cand not in usados_uf:
                usados[uf].add(cand)
                return cand
    
    # Último recurso (muito improvável chegar aqui)
    return "XXX"
